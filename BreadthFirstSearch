#include <iostream>
#include <vector>
#include <queue>

// Function to perform BFS traversal
std::vector<int> bfsOfGraph(int V, const std::vector<std::vector<int>>& adj, int startNode) {
    std::vector<int> bfsTraversal; // Stores the BFS traversal order
    std::vector<bool> visited(V, false); // Tracks visited nodes

    std::queue<int> q; // Queue for BFS

    // Mark the starting node as visited and enqueue it
    visited[startNode] = true;
    q.push(startNode);

    while (!q.empty()) {
        int currentNode = q.front();
        q.pop();
        bfsTraversal.push_back(currentNode);

        // Explore all unvisited neighbors of the current node
        for (int neighbor : adj[currentNode]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
    return bfsTraversal;
}

// Function to add an edge to the graph (undirected)
void addEdge(std::vector<std::vector<int>>& adj, int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u); // For undirected graph
}

int main() {
    int V = 5; // Number of vertices
    std::vector<std::vector<int>> adj(V); // Adjacency list representation

    // Add edges to the graph
    addEdge(adj, 0, 1);
    addEdge(adj, 0, 2);
    addEdge(adj, 1, 3);
    addEdge(adj, 1, 4);
    addEdge(adj, 2, 4);

    int startNode = 0; // Starting node for BFS

    std::vector<int> result = bfsOfGraph(V, adj, startNode);

    std::cout << "BFS Traversal starting from node " << startNode << ": ";
    for (int node : result) {
        std::cout << node << " ";
    }
    std::cout << std::endl;

    return 0;
}
